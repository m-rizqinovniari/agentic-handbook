"use strict";(globalThis.webpackChunklearning_materials=globalThis.webpackChunklearning_materials||[]).push([[818],{6608(e,n,t){t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"module-3-architectures-patterns/chapter-3","title":"ReAct, Plan-and-Execute, and Reflexion Patterns","description":"Learning Objectives","source":"@site/docs/module-3-architectures-patterns/chapter-3.md","sourceDirName":"module-3-architectures-patterns","slug":"/module-3-architectures-patterns/chapter-3","permalink":"/en/module-3-architectures-patterns/chapter-3","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"ReAct, Plan-and-Execute, and Reflexion Patterns","sidebar_position":3,"part":3,"part_title":"Agent Architectures and Design Patterns"},"sidebar":"tutorialSidebar","previous":{"title":"Single-Agent vs Multi-Agent Systems","permalink":"/en/module-3-architectures-patterns/chapter-2"},"next":{"title":"Design Trade-offs and Constraints","permalink":"/en/module-3-architectures-patterns/chapter-4"}}');var s=t(4848),r=t(8453);const a={title:"ReAct, Plan-and-Execute, and Reflexion Patterns",sidebar_position:3,part:3,part_title:"Agent Architectures and Design Patterns"},l="Agent Architectures and Design Patterns: ReAct, Plan-and-Execute, and Reflexion Patterns",o={},d=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Introduction",id:"introduction",level:2},{value:"ReAct Pattern Fundamentals",id:"react-pattern-fundamentals",level:2},{value:"Concrete Examples and Analogies",id:"concrete-examples-and-analogies",level:3},{value:"Strengths and Limitations",id:"strengths-and-limitations",level:3},{value:"ReAct Workflow Diagram",id:"react-workflow-diagram",level:3},{value:"Plan-and-Execute Workflow",id:"plan-and-execute-workflow",level:2},{value:"Why Plan-and-Execute Matters",id:"why-plan-and-execute-matters",level:3},{value:"Example: Report Generation Agent",id:"example-report-generation-agent",level:3},{value:"Comparison with ReAct",id:"comparison-with-react",level:3},{value:"Plan-and-Execute Diagram",id:"plan-and-execute-diagram",level:3},{value:"Reflexion and Self-Improvement Loops",id:"reflexion-and-self-improvement-loops",level:2},{value:"Practical Importance",id:"practical-importance",level:3},{value:"Reflexion Cycle Diagram",id:"reflexion-cycle-diagram",level:3},{value:"Benefits and Trade-offs",id:"benefits-and-trade-offs",level:3},{value:"Case Study: Building a Customer Support Agent with ReAct and Reflexion",id:"case-study-building-a-customer-support-agent-with-react-and-reflexion",level:2},{value:"Context",id:"context",level:3},{value:"Problem",id:"problem",level:3},{value:"Solution",id:"solution",level:3},{value:"Results",id:"results",level:3},{value:"Lessons Learned",id:"lessons-learned",level:3},{value:"Pattern Composition and Chaining",id:"pattern-composition-and-chaining",level:2},{value:"Composite Architecture Diagram",id:"composite-architecture-diagram",level:3},{value:"Benefits of Composition",id:"benefits-of-composition",level:3},{value:"Failure Handling Within Patterns",id:"failure-handling-within-patterns",level:2},{value:"Failure Handling Comparison",id:"failure-handling-comparison",level:3},{value:"Pattern Selection Guidelines",id:"pattern-selection-guidelines",level:2},{value:"Practical Guidelines",id:"practical-guidelines",level:3},{value:"Summary",id:"summary",level:2},{value:"Reflection Questions",id:"reflection-questions",level:2}];function c(e){const n={em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",mermaid:"mermaid",ol:"ol",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"agent-architectures-and-design-patterns-react-plan-and-execute-and-reflexion-patterns",children:"Agent Architectures and Design Patterns: ReAct, Plan-and-Execute, and Reflexion Patterns"})}),"\n",(0,s.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Explain core agent design patterns"}),"\n",(0,s.jsx)(n.li,{children:"Apply ReAct and Plan-and-Execute concepts"}),"\n",(0,s.jsx)(n.li,{children:"Analyze Reflexion for self-correction"}),"\n",(0,s.jsx)(n.li,{children:"Combine patterns for complex tasks"}),"\n",(0,s.jsx)(n.li,{children:"Evaluate pattern effectiveness"}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsx)(n.p,{children:"This chapter examines widely used agent design patterns and their practical applications."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsxs)(n.p,{children:["As large language models (LLMs) and autonomous agents have moved from research labs into real-world products, a critical challenge has emerged: ",(0,s.jsx)(n.strong,{children:"how should we structure an agent\u2019s reasoning and actions so that it behaves reliably, adaptively, and efficiently?"})," Early systems often relied on single-pass prompting\u2014ask a question, get an answer\u2014but this approach quickly breaks down for complex, multi-step, or uncertain tasks. Real-world problems require agents that can reason, act, observe outcomes, revise their plans, and learn from mistakes."]}),"\n",(0,s.jsxs)(n.p,{children:["This need gave rise to ",(0,s.jsx)(n.strong,{children:"agent architectures and design patterns"}),"\u2014reusable, well-tested ways of organizing how an agent thinks, decides, and interacts with tools and environments. Among the most influential patterns are ",(0,s.jsx)(n.strong,{children:"ReAct"}),", ",(0,s.jsx)(n.strong,{children:"Plan-and-Execute"}),", and ",(0,s.jsx)(n.strong,{children:"Reflexion"}),". These patterns are not just academic ideas; they are practical blueprints used in production systems for tasks like software debugging, data analysis, customer support automation, research assistance, and autonomous decision-making."]}),"\n",(0,s.jsx)(n.p,{children:"In this chapter, we take a deep, structured journey through these patterns. We begin with foundational ideas and progressively build toward advanced concepts such as pattern composition, failure handling, and selection guidelines. Along the way, we will use detailed explanations, analogies, real-world examples, tables, diagrams, and narrative case studies to ensure not just familiarity\u2014but true understanding."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.p,{children:"By the end of this chapter, you will be able to:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Explain the core principles behind major agent design patterns"}),"\n",(0,s.jsx)(n.li,{children:"Understand and apply the ReAct and Plan-and-Execute workflows"}),"\n",(0,s.jsx)(n.li,{children:"Analyze how Reflexion enables self-correction and improvement"}),"\n",(0,s.jsx)(n.li,{children:"Combine multiple patterns to solve complex, real-world tasks"}),"\n",(0,s.jsx)(n.li,{children:"Evaluate the effectiveness and trade-offs of different patterns"}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"react-pattern-fundamentals",children:"ReAct Pattern Fundamentals"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.strong,{children:"ReAct pattern"}),", short for ",(0,s.jsx)(n.em,{children:"Reasoning + Acting"}),", represents one of the most influential shifts in how agents are designed. Traditionally, language models were treated as static reasoning engines: they received a prompt, generated a response, and stopped. ReAct challenges this assumption by tightly interleaving ",(0,s.jsx)(n.strong,{children:"internal reasoning"})," with ",(0,s.jsx)(n.strong,{children:"external actions"}),", allowing agents to think step by step while actively interacting with tools, APIs, or environments."]}),"\n",(0,s.jsxs)(n.p,{children:["Historically, ReAct emerged from the observation that models perform better when they can externalize intermediate reasoning steps and immediately test those thoughts through actions. Instead of reasoning in isolation and hoping the answer is correct, a ReAct agent continuously asks: ",(0,s.jsx)(n.em,{children:"What do I know? What should I do next? What did I observe as a result?"})," This loop mirrors how humans solve problems\u2014thinking, trying something, observing the outcome, and adjusting accordingly."]}),"\n",(0,s.jsx)(n.p,{children:"At a conceptual level, the ReAct pattern operates as a repeating cycle:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Thought (Reasoning)"})," \u2013 The agent reflects on the current state and decides what to do next."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Action"})," \u2013 The agent invokes a tool, queries a database, calls an API, or performs an operation."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Observation"})," \u2013 The agent receives feedback from the environment and incorporates it into its reasoning."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"This cycle continues until the task is completed. The key insight is that reasoning is no longer hidden or static\u2014it directly drives action, and action informs subsequent reasoning."}),"\n",(0,s.jsxs)(n.p,{children:["Why is this important? Because many real-world tasks are ",(0,s.jsx)(n.strong,{children:"non-deterministic and information-incomplete"}),". For example:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"A research agent may not know which sources are relevant until it searches."}),"\n",(0,s.jsx)(n.li,{children:"A debugging agent may not know the cause of an error until it runs the code."}),"\n",(0,s.jsx)(n.li,{children:"A customer support agent may need to ask clarifying questions before resolving an issue."}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"ReAct excels in these situations because it embraces uncertainty rather than trying to eliminate it upfront."}),"\n",(0,s.jsx)(n.h3,{id:"concrete-examples-and-analogies",children:"Concrete Examples and Analogies"}),"\n",(0,s.jsxs)(n.p,{children:["A useful analogy is a ",(0,s.jsx)(n.strong,{children:"human detective"}),". The detective does not sit in a room and reason endlessly. Instead, they:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Form a hypothesis (reasoning)"}),"\n",(0,s.jsx)(n.li,{children:"Interview a witness or inspect a location (action)"}),"\n",(0,s.jsx)(n.li,{children:"Update their theory based on new evidence (observation)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Similarly, a ReAct agent alternates between thinking and doing."}),"\n",(0,s.jsxs)(n.p,{children:["Another example is ",(0,s.jsx)(n.strong,{children:"interactive data analysis"}),". An agent analyzing sales data might:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Reason that revenue dropped in Q3"}),"\n",(0,s.jsx)(n.li,{children:"Query the database for regional breakdowns"}),"\n",(0,s.jsx)(n.li,{children:"Observe that one region underperformed"}),"\n",(0,s.jsx)(n.li,{children:"Decide to analyze marketing spend in that region"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"strengths-and-limitations",children:"Strengths and Limitations"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Advantages of ReAct"})," include:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"High adaptability in dynamic environments"}),"\n",(0,s.jsx)(n.li,{children:"Improved factual grounding through tool use"}),"\n",(0,s.jsx)(n.li,{children:"Transparent reasoning steps (useful for debugging and trust)"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"However, ReAct also has limitations:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"It can become inefficient if reasoning loops are too long"}),"\n",(0,s.jsx)(n.li,{children:"Poorly designed prompts can lead to redundant or irrelevant actions"}),"\n",(0,s.jsx)(n.li,{children:"Without safeguards, agents may overuse tools or get stuck in cycles"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"react-workflow-diagram",children:"ReAct Workflow Diagram"}),"\n",(0,s.jsx)(n.mermaid,{value:"flowchart TD\r\n    A[Start Task] --\x3e B[Reasoning: What should I do next?]\r\n    B --\x3e C[Action: Use Tool / API]\r\n    C --\x3e D[Observation: Tool Output]\r\n    D --\x3e B\r\n    D --\x3e E[Task Completed]"}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"plan-and-execute-workflow",children:"Plan-and-Execute Workflow"}),"\n",(0,s.jsxs)(n.p,{children:["While ReAct emphasizes tight, moment-to-moment coupling between reasoning and action, the ",(0,s.jsx)(n.strong,{children:"Plan-and-Execute"})," pattern introduces a more deliberate and structured approach. This pattern separates ",(0,s.jsx)(n.em,{children:"strategic planning"})," from ",(0,s.jsx)(n.em,{children:"operational execution"}),", making it especially useful for long-horizon or complex tasks."]}),"\n",(0,s.jsx)(n.p,{children:"The historical roots of Plan-and-Execute lie in classical AI planning systems, where an agent first generated a plan and then executed it step by step. In modern LLM-based agents, this idea has been revived and adapted: the model first produces a high-level plan in natural language, then systematically carries out each step\u2014often using tools\u2014while monitoring progress."}),"\n",(0,s.jsx)(n.p,{children:"At a high level, the workflow consists of:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Goal Understanding"})," \u2013 Clarify the task and constraints."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Plan Generation"})," \u2013 Produce an ordered list of steps or subgoals."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Execution"})," \u2013 Carry out each step, often with tool calls."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Monitoring and Adjustment"})," \u2013 Detect failures and revise the plan if needed."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"This separation provides clarity and control. By explicitly writing down the plan, the agent reduces cognitive load during execution and makes its intentions transparent."}),"\n",(0,s.jsx)(n.h3,{id:"why-plan-and-execute-matters",children:"Why Plan-and-Execute Matters"}),"\n",(0,s.jsx)(n.p,{children:"Plan-and-Execute shines in scenarios where:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Tasks have many dependencies"}),"\n",(0,s.jsx)(n.li,{children:"Order of operations matters"}),"\n",(0,s.jsx)(n.li,{children:"Progress needs to be tracked or audited"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Examples include:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Generating a multi-section technical report"}),"\n",(0,s.jsx)(n.li,{children:"Migrating a database schema"}),"\n",(0,s.jsx)(n.li,{children:"Conducting a structured market analysis"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"In these cases, jumping directly into action (as ReAct might) can lead to wasted effort or missed steps."}),"\n",(0,s.jsx)(n.h3,{id:"example-report-generation-agent",children:"Example: Report Generation Agent"}),"\n",(0,s.jsx)(n.p,{children:"Consider an agent tasked with writing a 30-page market research report. Using Plan-and-Execute, it might:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Plan: outline sections, identify data sources, define analysis steps"}),"\n",(0,s.jsx)(n.li,{children:"Execute: gather data, write each section, compile visuals"}),"\n",(0,s.jsx)(n.li,{children:"Monitor: ensure consistency and completeness"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"This approach reduces the risk of producing an incoherent or incomplete output."}),"\n",(0,s.jsx)(n.h3,{id:"comparison-with-react",children:"Comparison with ReAct"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Dimension"}),(0,s.jsx)(n.th,{children:"ReAct"}),(0,s.jsx)(n.th,{children:"Plan-and-Execute"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Structure"}),(0,s.jsx)(n.td,{children:"Emergent"}),(0,s.jsx)(n.td,{children:"Explicit"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Flexibility"}),(0,s.jsx)(n.td,{children:"High"}),(0,s.jsx)(n.td,{children:"Moderate"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Transparency"}),(0,s.jsx)(n.td,{children:"Medium"}),(0,s.jsx)(n.td,{children:"High"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Best for"}),(0,s.jsx)(n.td,{children:"Exploration"}),(0,s.jsx)(n.td,{children:"Long tasks"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"plan-and-execute-diagram",children:"Plan-and-Execute Diagram"}),"\n",(0,s.jsx)(n.mermaid,{value:"sequenceDiagram\r\n    participant Agent\r\n    participant Planner\r\n    participant Executor\r\n    Agent->>Planner: Define goal\r\n    Planner->>Agent: Structured plan\r\n    Agent->>Executor: Execute step 1\r\n    Executor->>Agent: Result\r\n    Agent->>Executor: Execute next step"}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"reflexion-and-self-improvement-loops",children:"Reflexion and Self-Improvement Loops"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.strong,{children:"Reflexion pattern"})," introduces a powerful idea: agents should not only act and observe, but also ",(0,s.jsx)(n.strong,{children:"reflect on their past performance"})," to improve future behavior. Unlike ReAct, which focuses on immediate feedback, Reflexion emphasizes ",(0,s.jsx)(n.strong,{children:"meta-cognition"}),"\u2014thinking about one\u2019s own thinking and actions over time."]}),"\n",(0,s.jsxs)(n.p,{children:["This concept draws inspiration from human learning. When humans fail an exam or make a mistake at work, they do not just correct the error\u2014they reflect on ",(0,s.jsx)(n.em,{children:"why"})," it happened and adjust their strategies. Reflexion brings this capability into agent design."]}),"\n",(0,s.jsx)(n.p,{children:"A Reflexion loop typically involves:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Recording actions, outcomes, and errors"}),"\n",(0,s.jsx)(n.li,{children:"Analyzing what went wrong or right"}),"\n",(0,s.jsx)(n.li,{children:"Generating lessons, rules, or heuristics"}),"\n",(0,s.jsx)(n.li,{children:"Applying those insights to future attempts"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Importantly, Reflexion often operates across episodes, not just within a single task."}),"\n",(0,s.jsx)(n.h3,{id:"practical-importance",children:"Practical Importance"}),"\n",(0,s.jsx)(n.p,{children:"Reflexion is crucial in environments where:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Tasks are repeated with variations"}),"\n",(0,s.jsx)(n.li,{children:"Errors are costly"}),"\n",(0,s.jsx)(n.li,{children:"Continuous improvement is expected"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Examples include:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Automated code generation and debugging"}),"\n",(0,s.jsx)(n.li,{children:"Customer support agents handling recurring issues"}),"\n",(0,s.jsx)(n.li,{children:"Game-playing or simulation agents"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"reflexion-cycle-diagram",children:"Reflexion Cycle Diagram"}),"\n",(0,s.jsx)(n.mermaid,{value:"stateDiagram-v2\r\n    [*] --\x3e Attempt\r\n    Attempt --\x3e Outcome\r\n    Outcome --\x3e Reflection\r\n    Reflection --\x3e UpdatedStrategy\r\n    UpdatedStrategy --\x3e Attempt"}),"\n",(0,s.jsx)(n.h3,{id:"benefits-and-trade-offs",children:"Benefits and Trade-offs"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Advantages"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Reduces repeated mistakes"}),"\n",(0,s.jsx)(n.li,{children:"Enables learning without retraining"}),"\n",(0,s.jsx)(n.li,{children:"Improves long-term performance"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Challenges"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Requires memory management"}),"\n",(0,s.jsx)(n.li,{children:"Risk of overfitting to past errors"}),"\n",(0,s.jsx)(n.li,{children:"Additional computational overhead"}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"case-study-building-a-customer-support-agent-with-react-and-reflexion",children:"Case Study: Building a Customer Support Agent with ReAct and Reflexion"}),"\n",(0,s.jsx)(n.h3,{id:"context",children:"Context"}),"\n",(0,s.jsx)(n.p,{children:"A mid-sized SaaS company faced increasing customer support requests related to billing, integrations, and account management. Human agents were overwhelmed, and response times were growing. Leadership decided to build an AI support agent capable of resolving common issues autonomously while escalating complex cases."}),"\n",(0,s.jsx)(n.h3,{id:"problem",children:"Problem"}),"\n",(0,s.jsx)(n.p,{children:"Early prototypes used simple question-answering prompts. While fast, these systems often hallucinated answers or failed when information was missing. They could not ask clarifying questions or learn from past failures. Customer trust suffered, and escalation rates remained high."}),"\n",(0,s.jsx)(n.h3,{id:"solution",children:"Solution"}),"\n",(0,s.jsxs)(n.p,{children:["The team adopted a ",(0,s.jsx)(n.strong,{children:"ReAct architecture"})," for real-time interactions. The agent reasoned about each query, queried internal knowledge bases, and observed results before responding. To improve over time, a ",(0,s.jsx)(n.strong,{children:"Reflexion layer"})," was added. After each failed or escalated interaction, the agent analyzed what went wrong and stored lessons such as \u201cask for account ID before checking billing.\u201d"]}),"\n",(0,s.jsx)(n.h3,{id:"results",children:"Results"}),"\n",(0,s.jsx)(n.p,{children:"Within three months:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"First-contact resolution improved by 35%"}),"\n",(0,s.jsx)(n.li,{children:"Escalations dropped by 22%"}),"\n",(0,s.jsx)(n.li,{children:"Customer satisfaction scores increased"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The agent became noticeably better at handling edge cases."}),"\n",(0,s.jsx)(n.h3,{id:"lessons-learned",children:"Lessons Learned"}),"\n",(0,s.jsx)(n.p,{children:"The team learned that ReAct provided flexibility, but Reflexion was essential for long-term improvement. They also discovered the importance of carefully curating reflection memory to avoid noisy or irrelevant lessons."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"pattern-composition-and-chaining",children:"Pattern Composition and Chaining"}),"\n",(0,s.jsxs)(n.p,{children:["In practice, sophisticated agents rarely rely on a single pattern. Instead, they ",(0,s.jsx)(n.strong,{children:"compose and chain multiple patterns"})," to leverage their complementary strengths. Pattern composition is about architectural design\u2014deciding which pattern governs which phase of behavior."]}),"\n",(0,s.jsx)(n.p,{children:"A common composition is:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Plan-and-Execute"})," for high-level structure"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"ReAct"})," within each execution step"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Reflexion"})," across task episodes"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"This layered approach mirrors organizational structures: executives plan, teams execute adaptively, and retrospectives drive improvement."}),"\n",(0,s.jsx)(n.h3,{id:"composite-architecture-diagram",children:"Composite Architecture Diagram"}),"\n",(0,s.jsx)(n.mermaid,{value:"graph TD\r\n    A[Goal] --\x3e B[Plan-and-Execute]\r\n    B --\x3e C[ReAct Execution]\r\n    C --\x3e D[Outcome]\r\n    D --\x3e E[Reflexion Memory]\r\n    E --\x3e B"}),"\n",(0,s.jsx)(n.h3,{id:"benefits-of-composition",children:"Benefits of Composition"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Balances structure and flexibility"}),"\n",(0,s.jsx)(n.li,{children:"Enables scalability"}),"\n",(0,s.jsx)(n.li,{children:"Improves robustness"}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"failure-handling-within-patterns",children:"Failure Handling Within Patterns"}),"\n",(0,s.jsxs)(n.p,{children:["Failures are inevitable in real-world environments. Robust agent design treats failure not as an exception, but as a ",(0,s.jsx)(n.strong,{children:"first-class concept"}),". Each pattern handles failure differently."]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"ReAct"})," handles failure by immediate adjustment"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Plan-and-Execute"})," handles failure through replanning"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Reflexion"})," handles failure through learning"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Common failure modes include:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Tool errors"}),"\n",(0,s.jsx)(n.li,{children:"Incomplete information"}),"\n",(0,s.jsx)(n.li,{children:"Ambiguous goals"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"failure-handling-comparison",children:"Failure Handling Comparison"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Pattern"}),(0,s.jsx)(n.th,{children:"Failure Response"}),(0,s.jsx)(n.th,{children:"Time Horizon"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"ReAct"}),(0,s.jsx)(n.td,{children:"Immediate retry"}),(0,s.jsx)(n.td,{children:"Short"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Plan-and-Execute"}),(0,s.jsx)(n.td,{children:"Replan"}),(0,s.jsx)(n.td,{children:"Medium"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Reflexion"}),(0,s.jsx)(n.td,{children:"Strategy update"}),(0,s.jsx)(n.td,{children:"Long"})]})]})]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"pattern-selection-guidelines",children:"Pattern Selection Guidelines"}),"\n",(0,s.jsx)(n.p,{children:"Choosing the right pattern is a design decision shaped by task characteristics, constraints, and goals. There is no universally \u201cbest\u201d pattern."}),"\n",(0,s.jsx)(n.h3,{id:"practical-guidelines",children:"Practical Guidelines"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Use ",(0,s.jsx)(n.strong,{children:"ReAct"})," when environments are dynamic and exploratory"]}),"\n",(0,s.jsxs)(n.li,{children:["Use ",(0,s.jsx)(n.strong,{children:"Plan-and-Execute"})," for long, structured tasks"]}),"\n",(0,s.jsxs)(n.li,{children:["Use ",(0,s.jsx)(n.strong,{children:"Reflexion"})," when learning over time matters"]}),"\n",(0,s.jsx)(n.li,{children:"Combine patterns for complex systems"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"A helpful heuristic is to ask:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"How much uncertainty exists?"}),"\n",(0,s.jsx)(n.li,{children:"How long is the task horizon?"}),"\n",(0,s.jsx)(n.li,{children:"Is improvement over time required?"}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsx)(n.p,{children:"In this chapter, we explored three foundational agent design patterns\u2014ReAct, Plan-and-Execute, and Reflexion\u2014and examined how they shape intelligent behavior. We saw how ReAct enables adaptive interaction, how Plan-and-Execute provides structure and clarity, and how Reflexion supports self-improvement. By understanding their strengths, limitations, and combinations, you can design agents that are not only capable, but resilient and trustworthy."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"reflection-questions",children:"Reflection Questions"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Which pattern best fits a task you are currently working on, and why?"}),"\n",(0,s.jsx)(n.li,{children:"How might Reflexion change the long-term behavior of an agent in your domain?"}),"\n",(0,s.jsx)(n.li,{children:"What risks arise when combining multiple patterns, and how can they be mitigated?"}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453(e,n,t){t.d(n,{R:()=>a,x:()=>l});var i=t(6540);const s={},r=i.createContext(s);function a(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);