"use strict";(globalThis.webpackChunklearning_materials=globalThis.webpackChunklearning_materials||[]).push([[6722],{1235(e,n,r){r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>i,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"module-4-agent-frameworks/chapter-1","title":"Overview of Agentic AI Frameworks","description":"Learning Objectives","source":"@site/docs/module-4-agent-frameworks/chapter-1.md","sourceDirName":"module-4-agent-frameworks","slug":"/module-4-agent-frameworks/chapter-1","permalink":"/module-4-agent-frameworks/chapter-1","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"title":"Overview of Agentic AI Frameworks","sidebar_position":1,"part":4,"part_title":"Building Agents with Modern Frameworks"},"sidebar":"tutorialSidebar","previous":{"title":"Design Trade-offs and Constraints","permalink":"/module-3-architectures-patterns/chapter-4"},"next":{"title":"Tool Calling and Function Execution","permalink":"/module-4-agent-frameworks/chapter-2"}}');var t=r(4848),a=r(8453);const i={title:"Overview of Agentic AI Frameworks",sidebar_position:1,part:4,part_title:"Building Agents with Modern Frameworks"},o="Building Agents with Modern Frameworks: Overview of Agentic AI Frameworks",l={},d=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Motivation for Agent Frameworks",id:"motivation-for-agent-frameworks",level:2},{value:"Why Not Just Use Prompt Chaining?",id:"why-not-just-use-prompt-chaining",level:3},{value:"LangGraph Architecture Overview",id:"langgraph-architecture-overview",level:2},{value:"How LangGraph Works Step by Step",id:"how-langgraph-works-step-by-step",level:3},{value:"Strengths and Limitations of LangGraph",id:"strengths-and-limitations-of-langgraph",level:3},{value:"AutoGen and Conversational Agents",id:"autogen-and-conversational-agents",level:2},{value:"Practical Example: Research Assistant",id:"practical-example-research-assistant",level:3},{value:"CrewAI and Role-Based Agents",id:"crewai-and-role-based-agents",level:2},{value:"Framework Comparison Matrix",id:"framework-comparison-matrix",level:2},{value:"Selecting the Right Framework",id:"selecting-the-right-framework",level:2},{value:"Summary",id:"summary",level:2},{value:"Reflection Questions",id:"reflection-questions",level:2}];function h(e){const n={em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",mermaid:"mermaid",ol:"ol",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"building-agents-with-modern-frameworks-overview-of-agentic-ai-frameworks",children:"Building Agents with Modern Frameworks: Overview of Agentic AI Frameworks"})}),"\n",(0,t.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Explain the purpose of agent frameworks"}),"\n",(0,t.jsx)(n.li,{children:"Compare LangGraph, AutoGen, and CrewAI"}),"\n",(0,t.jsx)(n.li,{children:"Identify strengths of each framework"}),"\n",(0,t.jsx)(n.li,{children:"Select frameworks based on use cases"}),"\n",(0,t.jsx)(n.li,{children:"Evaluate framework limitations"}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,t.jsx)(n.p,{children:"This chapter introduces popular agent frameworks and compares their design philosophies and capabilities."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsxs)(n.p,{children:["Over the past few years, artificial intelligence has moved beyond single-turn question answering and static machine learning models into a new paradigm: ",(0,t.jsx)(n.strong,{children:"agentic AI"}),". In this paradigm, AI systems are not just passive responders; they can ",(0,t.jsx)(n.strong,{children:"plan"}),", ",(0,t.jsx)(n.strong,{children:"reason"}),", ",(0,t.jsx)(n.strong,{children:"act"}),", ",(0,t.jsx)(n.strong,{children:"collaborate"}),", and ",(0,t.jsx)(n.strong,{children:"adapt over time"})," to achieve complex goals. These systems\u2014commonly referred to as ",(0,t.jsx)(n.em,{children:"AI agents"}),"\u2014are increasingly used in real-world applications such as autonomous research assistants, software development copilots, customer support automation, and multi-step business process orchestration."]}),"\n",(0,t.jsxs)(n.p,{children:["However, building such agents from scratch is extremely challenging. Developers must manage conversation state, memory, tool usage, decision logic, error handling, and often coordination between multiple agents. As agent behaviors grow more complex, ad-hoc code quickly becomes fragile, difficult to debug, and nearly impossible to scale. This challenge has led to the rise of ",(0,t.jsx)(n.strong,{children:"agentic AI frameworks"}),"\u2014specialized software frameworks designed to structure, orchestrate, and manage intelligent agents in a systematic way."]}),"\n",(0,t.jsxs)(n.p,{children:["This chapter introduces three of the most influential modern agent frameworks\u2014",(0,t.jsx)(n.strong,{children:"LangGraph"}),", ",(0,t.jsx)(n.strong,{children:"AutoGen"}),", and ",(0,t.jsx)(n.strong,{children:"CrewAI"}),"\u2014and explains their underlying design philosophies, architectural patterns, and practical trade-offs. Rather than focusing on syntax or API details, we will explore ",(0,t.jsx)(n.em,{children:"why"})," these frameworks exist, ",(0,t.jsx)(n.em,{children:"how"})," they think about agents, and ",(0,t.jsx)(n.em,{children:"when"})," each framework is the right choice. By the end of this chapter, you should be able to reason critically about agent frameworks and select one that aligns with your technical constraints and business goals."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.p,{children:"By the end of this chapter, you will be able to:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Explain why agent frameworks are necessary for building reliable and scalable AI agents"}),"\n",(0,t.jsx)(n.li,{children:"Describe the core architectural ideas behind LangGraph, AutoGen, and CrewAI"}),"\n",(0,t.jsx)(n.li,{children:"Compare these frameworks in terms of design philosophy, strengths, and limitations"}),"\n",(0,t.jsx)(n.li,{children:"Identify which framework is best suited for specific real-world use cases"}),"\n",(0,t.jsx)(n.li,{children:"Evaluate trade-offs and risks when adopting an agentic AI framework"}),"\n"]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"motivation-for-agent-frameworks",children:"Motivation for Agent Frameworks"}),"\n",(0,t.jsxs)(n.p,{children:["The motivation for agent frameworks arises from a fundamental shift in how we use large language models (LLMs). Early LLM applications treated models like advanced calculators: you sent a prompt and received a response. While powerful, this interaction model breaks down when tasks require ",(0,t.jsx)(n.strong,{children:"multiple steps, long-term memory, conditional logic, or interaction with external tools"}),". As soon as developers began chaining prompts together, they encountered serious engineering challenges."]}),"\n",(0,t.jsxs)(n.p,{children:["One of the earliest problems was ",(0,t.jsx)(n.strong,{children:"state management"}),". Consider a simple customer support agent that must remember a user\u2019s issue across multiple messages, query a knowledge base, ask clarifying questions, and escalate to a human if needed. Without a framework, developers often resort to fragile patterns: global variables, ad-hoc JSON blobs, or overly complex prompt engineering. These approaches quickly become unmaintainable, especially when multiple agents or parallel conversations are involved."]}),"\n",(0,t.jsxs)(n.p,{children:["Another major driver for agent frameworks is ",(0,t.jsx)(n.strong,{children:"reliability and control"}),". LLMs are probabilistic systems, which means they can behave unpredictably. When an agent is expected to perform real-world actions\u2014such as sending emails, modifying databases, or executing code\u2014developers need safeguards. Frameworks provide structured execution models, explicit transitions, and guardrails that make agent behavior more predictable and auditable. This is especially important in regulated industries like finance, healthcare, and enterprise IT."]}),"\n",(0,t.jsxs)(n.p,{children:["Finally, agent frameworks address the need for ",(0,t.jsx)(n.strong,{children:"collaboration and specialization"}),". Real-world problems are rarely solved by a single generalist. Human organizations rely on specialized roles\u2014analysts, planners, executors, reviewers\u2014and AI systems are increasingly mirroring this structure. Frameworks like AutoGen and CrewAI explicitly model multi-agent collaboration, allowing agents to debate, delegate, and validate each other\u2019s work. This mirrors human workflows and often leads to higher-quality outcomes."]}),"\n",(0,t.jsx)(n.h3,{id:"why-not-just-use-prompt-chaining",children:"Why Not Just Use Prompt Chaining?"}),"\n",(0,t.jsx)(n.p,{children:"To better understand the motivation, it helps to compare agent frameworks with simpler approaches."}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Approach"}),(0,t.jsx)(n.th,{children:"Strengths"}),(0,t.jsx)(n.th,{children:"Weaknesses"}),(0,t.jsx)(n.th,{children:"Suitable Use Cases"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Single Prompt"}),(0,t.jsx)(n.td,{children:"Simple, fast"}),(0,t.jsx)(n.td,{children:"No memory, no reasoning"}),(0,t.jsx)(n.td,{children:"FAQs, simple Q&A"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Prompt Chaining"}),(0,t.jsx)(n.td,{children:"More capable"}),(0,t.jsx)(n.td,{children:"Fragile, hard to debug"}),(0,t.jsx)(n.td,{children:"Small workflows"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Agent Frameworks"}),(0,t.jsx)(n.td,{children:"Structured, scalable"}),(0,t.jsx)(n.td,{children:"Learning curve"}),(0,t.jsx)(n.td,{children:"Complex, multi-step tasks"})]})]})]}),"\n",(0,t.jsx)(n.p,{children:"Prompt chaining is like writing a script without functions or error handling. Agent frameworks, by contrast, are more like full application frameworks\u2014they impose structure, but that structure enables scale and reliability."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"langgraph-architecture-overview",children:"LangGraph Architecture Overview"}),"\n",(0,t.jsxs)(n.p,{children:["LangGraph represents a ",(0,t.jsx)(n.strong,{children:"state-machine-driven approach"})," to agent design. Developed as part of the LangChain ecosystem, it addresses one of the biggest pain points in agent development: uncontrolled execution flow. Instead of letting agents \u201cfreely roam\u201d through prompts and tools, LangGraph forces developers to define explicit states and transitions."]}),"\n",(0,t.jsxs)(n.p,{children:["At its core, LangGraph models agent behavior as a ",(0,t.jsx)(n.strong,{children:"directed graph"}),". Each node represents a unit of computation\u2014such as calling an LLM, invoking a tool, or evaluating a condition\u2014while edges define how execution flows from one node to another. This design is inspired by workflow engines and finite state machines, which have been used for decades in distributed systems and business process automation."]}),"\n",(0,t.jsx)(n.p,{children:"The importance of this design becomes clear when agents must handle loops, retries, and branching logic. For example, an agent might repeatedly refine a search query until sufficient information is found, or loop back to a clarification step if the user\u2019s intent is unclear. In LangGraph, these behaviors are not implicit\u2014they are explicitly encoded in the graph, making them easier to reason about and debug."}),"\n",(0,t.jsxs)(n.p,{children:["Another defining feature of LangGraph is its emphasis on ",(0,t.jsx)(n.strong,{children:"state"}),". Rather than passing information implicitly through prompts, LangGraph maintains a shared, structured state object. Each node can read from and write to this state, enabling clean separation of concerns. This design mirrors how traditional software systems manage shared memory or context objects."]}),"\n",(0,t.jsx)(n.h3,{id:"how-langgraph-works-step-by-step",children:"How LangGraph Works Step by Step"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Define a shared state schema (e.g., conversation history, task status)."}),"\n",(0,t.jsx)(n.li,{children:"Create nodes that perform specific actions."}),"\n",(0,t.jsx)(n.li,{children:"Connect nodes using directed edges."}),"\n",(0,t.jsx)(n.li,{children:"Specify conditional transitions."}),"\n",(0,t.jsx)(n.li,{children:"Execute the graph and observe state evolution."}),"\n"]}),"\n",(0,t.jsx)(n.mermaid,{value:"flowchart TD\r\n    Start --\x3e LLMNode\r\n    LLMNode --\x3e|Needs Tool| ToolNode\r\n    ToolNode --\x3e LLMNode\r\n    LLMNode --\x3e|Done| End"}),"\n",(0,t.jsx)(n.h3,{id:"strengths-and-limitations-of-langgraph",children:"Strengths and Limitations of LangGraph"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Aspect"}),(0,t.jsx)(n.th,{children:"Strength"}),(0,t.jsx)(n.th,{children:"Limitation"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Control"}),(0,t.jsx)(n.td,{children:"Highly deterministic"}),(0,t.jsx)(n.td,{children:"Less flexible"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Debugging"}),(0,t.jsx)(n.td,{children:"Clear execution paths"}),(0,t.jsx)(n.td,{children:"More setup"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Scaling"}),(0,t.jsx)(n.td,{children:"Suitable for complex flows"}),(0,t.jsx)(n.td,{children:"Verbose definitions"})]})]})]}),"\n",(0,t.jsxs)(n.p,{children:["LangGraph is ideal for ",(0,t.jsx)(n.strong,{children:"production-grade agents"})," where predictability, observability, and correctness matter more than rapid prototyping."]}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"autogen-and-conversational-agents",children:"AutoGen and Conversational Agents"}),"\n",(0,t.jsxs)(n.p,{children:["AutoGen takes a fundamentally different approach. Instead of graphs or workflows, AutoGen models agent systems as ",(0,t.jsx)(n.strong,{children:"structured conversations"})," between autonomous agents. Each agent is defined by a role, a system prompt, and a set of capabilities. These agents then communicate with each other through messages, much like humans in a group chat."]}),"\n",(0,t.jsxs)(n.p,{children:["The historical roots of AutoGen lie in research on ",(0,t.jsx)(n.strong,{children:"multi-agent systems and deliberative reasoning"}),". Researchers observed that LLMs often perform better when they are allowed to critique, refine, or build upon each other\u2019s outputs. AutoGen operationalizes this insight by making conversation the primary coordination mechanism."]}),"\n",(0,t.jsxs)(n.p,{children:["One of AutoGen\u2019s key advantages is its ",(0,t.jsx)(n.strong,{children:"naturalness"}),". Developers do not need to define explicit state machines or transitions. Instead, they specify who the agents are and what they can do, then allow the conversation to unfold. This makes AutoGen particularly appealing for exploratory tasks like research, brainstorming, and code generation."]}),"\n",(0,t.jsx)(n.p,{children:"However, this flexibility comes at a cost. Because execution flow emerges from conversation, it can be harder to guarantee termination, enforce constraints, or debug failures. AutoGen systems often require careful prompt design and monitoring to avoid runaway loops or inconsistent behavior."}),"\n",(0,t.jsx)(n.mermaid,{value:"sequenceDiagram\r\n    User->>Planner: Task Request\r\n    Planner->>Researcher: Gather Information\r\n    Researcher->>Planner: Findings\r\n    Planner->>Executor: Perform Action\r\n    Executor->>User: Result"}),"\n",(0,t.jsx)(n.h3,{id:"practical-example-research-assistant",children:"Practical Example: Research Assistant"}),"\n",(0,t.jsx)(n.p,{children:"Imagine a market research assistant composed of three agents: a planner, a researcher, and a writer. The planner breaks down the task, the researcher gathers data, and the writer synthesizes insights. AutoGen excels in this scenario because the task is open-ended and benefits from iterative refinement."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"crewai-and-role-based-agents",children:"CrewAI and Role-Based Agents"}),"\n",(0,t.jsxs)(n.p,{children:["CrewAI introduces yet another perspective by explicitly modeling ",(0,t.jsx)(n.strong,{children:"teams and roles"}),". Inspired by organizational theory, CrewAI assumes that complex tasks are best solved by a coordinated \u201ccrew\u201d of agents, each with a well-defined responsibility."]}),"\n",(0,t.jsxs)(n.p,{children:["In CrewAI, agents are not just conversational entities; they are ",(0,t.jsx)(n.strong,{children:"workers"})," with specific goals, tools, and authority. A crew typically includes roles such as strategist, executor, reviewer, and coordinator. This structure aligns closely with how human teams operate, making it intuitive for business users."]}),"\n",(0,t.jsxs)(n.p,{children:["One of CrewAI\u2019s distinguishing features is its ",(0,t.jsx)(n.strong,{children:"task-first design"}),". Developers define tasks and assign them to roles, rather than letting tasks emerge organically through conversation. This leads to clearer accountability and easier evaluation of outcomes."]}),"\n",(0,t.jsx)(n.p,{children:"However, CrewAI can feel rigid for exploratory or creative tasks. Its strength lies in repeatable, goal-oriented workflows such as content production pipelines, software delivery processes, and business analysis."}),"\n",(0,t.jsx)(n.mermaid,{value:"graph LR\r\n    Manager --\x3e Analyst\r\n    Analyst --\x3e Writer\r\n    Writer --\x3e Reviewer\r\n    Reviewer --\x3e Manager"}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"framework-comparison-matrix",children:"Framework Comparison Matrix"}),"\n",(0,t.jsx)(n.p,{children:"The differences between LangGraph, AutoGen, and CrewAI become clearer when viewed side by side."}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Dimension"}),(0,t.jsx)(n.th,{children:"LangGraph"}),(0,t.jsx)(n.th,{children:"AutoGen"}),(0,t.jsx)(n.th,{children:"CrewAI"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Core Metaphor"}),(0,t.jsx)(n.td,{children:"State Machine"}),(0,t.jsx)(n.td,{children:"Conversation"}),(0,t.jsx)(n.td,{children:"Team"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Control Level"}),(0,t.jsx)(n.td,{children:"Very High"}),(0,t.jsx)(n.td,{children:"Low\u2013Medium"}),(0,t.jsx)(n.td,{children:"Medium"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Best For"}),(0,t.jsx)(n.td,{children:"Production workflows"}),(0,t.jsx)(n.td,{children:"Exploration"}),(0,t.jsx)(n.td,{children:"Role-based tasks"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"Debugging"}),(0,t.jsx)(n.td,{children:"Strong"}),(0,t.jsx)(n.td,{children:"Challenging"}),(0,t.jsx)(n.td,{children:"Moderate"})]})]})]}),"\n",(0,t.jsx)(n.mermaid,{value:"quadrantChart\r\n    title Agent Framework Positioning\r\n    x-axis Flexibility --\x3e Structure\r\n    y-axis Exploration --\x3e Production\r\n    AutoGen: [0.2, 0.8]\r\n    LangGraph: [0.8, 0.9]\r\n    CrewAI: [0.6, 0.6]"}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"selecting-the-right-framework",children:"Selecting the Right Framework"}),"\n",(0,t.jsxs)(n.p,{children:["Choosing the right framework is less about which one is \u201cbest\u201d and more about ",(0,t.jsx)(n.strong,{children:"context"}),". Teams building regulated, mission-critical systems will gravitate toward LangGraph. Research teams and innovation labs may prefer AutoGen\u2019s freedom. Business process automation often aligns naturally with CrewAI."]}),"\n",(0,t.jsx)(n.p,{children:"Key questions to ask include:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"How predictable must agent behavior be?"}),"\n",(0,t.jsx)(n.li,{children:"Will multiple agents collaborate?"}),"\n",(0,t.jsx)(n.li,{children:"Is the task exploratory or well-defined?"}),"\n",(0,t.jsx)(n.li,{children:"Who will maintain the system?"}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"No framework is universally superior; each encodes a different philosophy about how intelligence should be organized."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsx)(n.p,{children:"In this chapter, we explored why agent frameworks are essential for modern AI systems and examined three leading frameworks through the lens of architecture, philosophy, and practical use. LangGraph emphasizes control and determinism, AutoGen embraces conversational emergence, and CrewAI mirrors human organizational structures. Understanding these differences allows you to design agent systems that are not only powerful, but also maintainable and trustworthy."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"reflection-questions",children:"Reflection Questions"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"How does your current or planned AI project align with the design philosophy of each framework?"}),"\n",(0,t.jsx)(n.li,{children:"What risks might arise from choosing a framework that is too flexible or too rigid?"}),"\n",(0,t.jsx)(n.li,{children:"How might hybrid approaches\u2014combining frameworks or ideas\u2014address complex requirements?"}),"\n",(0,t.jsx)(n.li,{children:"Which framework would you choose for a regulated industry use case, and why?"}),"\n",(0,t.jsx)(n.li,{children:"How do agent frameworks change the role of the human developer in AI system design?"}),"\n"]})]})}function c(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},8453(e,n,r){r.d(n,{R:()=>i,x:()=>o});var s=r(6540);const t={},a=s.createContext(t);function i(e){const n=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);